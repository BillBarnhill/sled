// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod sled {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
pub mod frag {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Frag {
  NONE = 0,
  Set = 1,
  Del = 2,
  Merge = 3,
  Base = 4,
  ChildSplit = 5,
  ParentSplit = 6,

}

const ENUM_MIN_FRAG: u8 = 0;
const ENUM_MAX_FRAG: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for Frag {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Frag {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Frag;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Frag;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Frag {
    type Output = Frag;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Frag>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FRAG:[Frag; 7] = [
  Frag::NONE,
  Frag::Set,
  Frag::Del,
  Frag::Merge,
  Frag::Base,
  Frag::ChildSplit,
  Frag::ParentSplit
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FRAG:[&'static str; 7] = [
    "NONE",
    "Set",
    "Del",
    "Merge",
    "Base",
    "ChildSplit",
    "ParentSplit"
];

pub fn enum_name_frag(e: Frag) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_FRAG[index]
}

pub struct FragUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Bound {
  NONE = 0,
  Inclusive = 1,
  Exclusive = 2,
  Infinity = 3,

}

const ENUM_MIN_BOUND: u8 = 0;
const ENUM_MAX_BOUND: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Bound {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Bound {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Bound;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Bound;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Bound {
    type Output = Bound;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Bound>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_BOUND:[Bound; 4] = [
  Bound::NONE,
  Bound::Inclusive,
  Bound::Exclusive,
  Bound::Infinity
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_BOUND:[&'static str; 4] = [
    "NONE",
    "Inclusive",
    "Exclusive",
    "Infinity"
];

pub fn enum_name_bound(e: Bound) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_BOUND[index]
}

pub struct BoundUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Data {
  NONE = 0,
  Leaf = 1,
  Index = 2,

}

const ENUM_MIN_DATA: u8 = 0;
const ENUM_MAX_DATA: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for Data {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Data {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Data;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Data;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Data {
    type Output = Data;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Data>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_DATA:[Data; 3] = [
  Data::NONE,
  Data::Leaf,
  Data::Index
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_DATA:[&'static str; 3] = [
    "NONE",
    "Leaf",
    "Index"
];

pub fn enum_name_data(e: Data) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_DATA[index]
}

pub struct DataUnionTableOffset {}
pub enum SetOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Set<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Set<'a> {
    type Inner = Set<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Set<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Set {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetArgs<'args>) -> flatbuffers::WIPOffset<Set<'bldr>> {
      let mut builder = SetBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Set::VT_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Set::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct SetArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for SetArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetArgs {
            key: None,
            value: None,
        }
    }
}
pub struct SetBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Set::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Set::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Set<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DelOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Del<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Del<'a> {
    type Inner = Del<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Del<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Del {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelArgs<'args>) -> flatbuffers::WIPOffset<Del<'bldr>> {
      let mut builder = DelBuilder::new(_fbb);
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Del::VT_KEY, None).map(|v| v.safe_slice())
  }
}

pub struct DelArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for DelArgs<'a> {
    #[inline]
    fn default() -> Self {
        DelArgs {
            key: None,
        }
    }
}
pub struct DelBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Del::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Del<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MergeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Merge<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Merge<'a> {
    type Inner = Merge<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Merge<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Merge {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeArgs<'args>) -> flatbuffers::WIPOffset<Merge<'bldr>> {
      let mut builder = MergeBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Merge::VT_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Merge::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct MergeArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for MergeArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeArgs {
            key: None,
            value: None,
        }
    }
}
pub struct MergeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Merge::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Merge::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MergeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MergeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Merge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ChildSplitOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ChildSplit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChildSplit<'a> {
    type Inner = ChildSplit<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ChildSplit<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ChildSplit {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ChildSplitArgs) -> flatbuffers::WIPOffset<ChildSplit<'bldr>> {
      let mut builder = ChildSplitBuilder::new(_fbb);
      builder.add_to(args.to);
      if let Some(x) = args.at { builder.add_at(x); }
      builder.add_at_type(args.at_type);
      builder.finish()
    }

    pub const VT_AT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_AT: flatbuffers::VOffsetT = 6;
    pub const VT_TO: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn at_type(&self) -> Bound {
    self._tab.get::<Bound>(ChildSplit::VT_AT_TYPE, Some(Bound::NONE)).unwrap()
  }
  #[inline]
  pub fn at(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ChildSplit::VT_AT, None)
  }
  #[inline]
  pub fn to(&self) -> u64 {
    self._tab.get::<u64>(ChildSplit::VT_TO, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn at_as_inclusive(&'a self) -> Option<Inclusive> {
    if self.at_type() == Bound::Inclusive {
      self.at().map(|u| Inclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn at_as_exclusive(&'a self) -> Option<Exclusive> {
    if self.at_type() == Bound::Exclusive {
      self.at().map(|u| Exclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn at_as_infinity(&'a self) -> Option<Infinity> {
    if self.at_type() == Bound::Infinity {
      self.at().map(|u| Infinity::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ChildSplitArgs {
    pub at_type: Bound,
    pub at: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub to: u64,
}
impl<'a> Default for ChildSplitArgs {
    #[inline]
    fn default() -> Self {
        ChildSplitArgs {
            at_type: Bound::NONE,
            at: None,
            to: 0,
        }
    }
}
pub struct ChildSplitBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChildSplitBuilder<'a, 'b> {
  #[inline]
  pub fn add_at_type(&mut self, at_type: Bound) {
    self.fbb_.push_slot::<Bound>(ChildSplit::VT_AT_TYPE, at_type, Bound::NONE);
  }
  #[inline]
  pub fn add_at(&mut self, at: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ChildSplit::VT_AT, at);
  }
  #[inline]
  pub fn add_to(&mut self, to: u64) {
    self.fbb_.push_slot::<u64>(ChildSplit::VT_TO, to, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChildSplitBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChildSplitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChildSplit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ParentSplitOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ParentSplit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParentSplit<'a> {
    type Inner = ParentSplit<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ParentSplit<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ParentSplit {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ParentSplitArgs) -> flatbuffers::WIPOffset<ParentSplit<'bldr>> {
      let mut builder = ParentSplitBuilder::new(_fbb);
      builder.add_to(args.to);
      if let Some(x) = args.at { builder.add_at(x); }
      builder.add_at_type(args.at_type);
      builder.finish()
    }

    pub const VT_AT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_AT: flatbuffers::VOffsetT = 6;
    pub const VT_TO: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn at_type(&self) -> Bound {
    self._tab.get::<Bound>(ParentSplit::VT_AT_TYPE, Some(Bound::NONE)).unwrap()
  }
  #[inline]
  pub fn at(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ParentSplit::VT_AT, None)
  }
  #[inline]
  pub fn to(&self) -> u64 {
    self._tab.get::<u64>(ParentSplit::VT_TO, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn at_as_inclusive(&'a self) -> Option<Inclusive> {
    if self.at_type() == Bound::Inclusive {
      self.at().map(|u| Inclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn at_as_exclusive(&'a self) -> Option<Exclusive> {
    if self.at_type() == Bound::Exclusive {
      self.at().map(|u| Exclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn at_as_infinity(&'a self) -> Option<Infinity> {
    if self.at_type() == Bound::Infinity {
      self.at().map(|u| Infinity::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ParentSplitArgs {
    pub at_type: Bound,
    pub at: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub to: u64,
}
impl<'a> Default for ParentSplitArgs {
    #[inline]
    fn default() -> Self {
        ParentSplitArgs {
            at_type: Bound::NONE,
            at: None,
            to: 0,
        }
    }
}
pub struct ParentSplitBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ParentSplitBuilder<'a, 'b> {
  #[inline]
  pub fn add_at_type(&mut self, at_type: Bound) {
    self.fbb_.push_slot::<Bound>(ParentSplit::VT_AT_TYPE, at_type, Bound::NONE);
  }
  #[inline]
  pub fn add_at(&mut self, at: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentSplit::VT_AT, at);
  }
  #[inline]
  pub fn add_to(&mut self, to: u64) {
    self.fbb_.push_slot::<u64>(ParentSplit::VT_TO, to, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ParentSplitBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ParentSplitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParentSplit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InclusiveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Inclusive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Inclusive<'a> {
    type Inner = Inclusive<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Inclusive<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Inclusive {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InclusiveArgs<'args>) -> flatbuffers::WIPOffset<Inclusive<'bldr>> {
      let mut builder = InclusiveBuilder::new(_fbb);
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Inclusive::VT_KEY, None).map(|v| v.safe_slice())
  }
}

pub struct InclusiveArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for InclusiveArgs<'a> {
    #[inline]
    fn default() -> Self {
        InclusiveArgs {
            key: None,
        }
    }
}
pub struct InclusiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InclusiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Inclusive::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InclusiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InclusiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Inclusive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExclusiveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Exclusive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Exclusive<'a> {
    type Inner = Exclusive<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Exclusive<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Exclusive {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExclusiveArgs<'args>) -> flatbuffers::WIPOffset<Exclusive<'bldr>> {
      let mut builder = ExclusiveBuilder::new(_fbb);
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Exclusive::VT_KEY, None).map(|v| v.safe_slice())
  }
}

pub struct ExclusiveArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ExclusiveArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExclusiveArgs {
            key: None,
        }
    }
}
pub struct ExclusiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExclusiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Exclusive::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExclusiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExclusiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Exclusive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InfinityOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Infinity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Infinity<'a> {
    type Inner = Infinity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Infinity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Infinity {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args InfinityArgs) -> flatbuffers::WIPOffset<Infinity<'bldr>> {
      let mut builder = InfinityBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct InfinityArgs {
}
impl<'a> Default for InfinityArgs {
    #[inline]
    fn default() -> Self {
        InfinityArgs {
        }
    }
}
pub struct InfinityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfinityBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfinityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InfinityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Infinity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum LeafOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Leaf<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Leaf<'a> {
    type Inner = Leaf<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Leaf<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Leaf {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeafArgs<'args>) -> flatbuffers::WIPOffset<Leaf<'bldr>> {
      let mut builder = LeafBuilder::new(_fbb);
      if let Some(x) = args.kvs { builder.add_kvs(x); }
      builder.finish()
    }

    pub const VT_KVS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn kvs(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Kv<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Kv<'a>>>>>(Leaf::VT_KVS, None)
  }
}

pub struct LeafArgs<'a> {
    pub kvs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Kv<'a >>>>>,
}
impl<'a> Default for LeafArgs<'a> {
    #[inline]
    fn default() -> Self {
        LeafArgs {
            kvs: None,
        }
    }
}
pub struct LeafBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeafBuilder<'a, 'b> {
  #[inline]
  pub fn add_kvs(&mut self, kvs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Kv<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Leaf::VT_KVS, kvs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeafBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeafBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Leaf<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum KvOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Kv<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kv<'a> {
    type Inner = Kv<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Kv<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Kv {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args KvArgs<'args>) -> flatbuffers::WIPOffset<Kv<'bldr>> {
      let mut builder = KvBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Kv::VT_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Kv::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct KvArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for KvArgs<'a> {
    #[inline]
    fn default() -> Self {
        KvArgs {
            key: None,
            value: None,
        }
    }
}
pub struct KvBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KvBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kv::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kv::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KvBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KvBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kv<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IndexOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Index<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Index<'a> {
    type Inner = Index<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Index<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Index {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IndexArgs<'args>) -> flatbuffers::WIPOffset<Index<'bldr>> {
      let mut builder = IndexBuilder::new(_fbb);
      if let Some(x) = args.children { builder.add_children(x); }
      builder.finish()
    }

    pub const VT_CHILDREN: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Child<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Child<'a>>>>>(Index::VT_CHILDREN, None)
  }
}

pub struct IndexArgs<'a> {
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Child<'a >>>>>,
}
impl<'a> Default for IndexArgs<'a> {
    #[inline]
    fn default() -> Self {
        IndexArgs {
            children: None,
        }
    }
}
pub struct IndexBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IndexBuilder<'a, 'b> {
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Child<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Index::VT_CHILDREN, children);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndexBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IndexBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Index<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ChildOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Child<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Child<'a> {
    type Inner = Child<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Child<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Child {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ChildArgs<'args>) -> flatbuffers::WIPOffset<Child<'bldr>> {
      let mut builder = ChildBuilder::new(_fbb);
      builder.add_id(args.id);
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Child::VT_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(Child::VT_ID, Some(0)).unwrap()
  }
}

pub struct ChildArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub id: u64,
}
impl<'a> Default for ChildArgs<'a> {
    #[inline]
    fn default() -> Self {
        ChildArgs {
            key: None,
            id: 0,
        }
    }
}
pub struct ChildBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChildBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Child::VT_KEY, key);
  }
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Child::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChildBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChildBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Child<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BaseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Base<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Base<'a> {
    type Inner = Base<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Base<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Base {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BaseArgs) -> flatbuffers::WIPOffset<Base<'bldr>> {
      let mut builder = BaseBuilder::new(_fbb);
      builder.add_replaced_root(args.replaced_root);
      builder.add_next(args.next);
      builder.add_id(args.id);
      if let Some(x) = args.hi { builder.add_hi(x); }
      if let Some(x) = args.lo { builder.add_lo(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      builder.add_hi_type(args.hi_type);
      builder.add_lo_type(args.lo_type);
      builder.add_data_type(args.data_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;
    pub const VT_NEXT: flatbuffers::VOffsetT = 10;
    pub const VT_LO_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_LO: flatbuffers::VOffsetT = 14;
    pub const VT_HI_TYPE: flatbuffers::VOffsetT = 16;
    pub const VT_HI: flatbuffers::VOffsetT = 18;
    pub const VT_REPLACED_ROOT: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(Base::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn data_type(&self) -> Data {
    self._tab.get::<Data>(Base::VT_DATA_TYPE, Some(Data::NONE)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Base::VT_DATA, None)
  }
  #[inline]
  pub fn next(&self) -> u64 {
    self._tab.get::<u64>(Base::VT_NEXT, Some(0)).unwrap()
  }
  #[inline]
  pub fn lo_type(&self) -> Bound {
    self._tab.get::<Bound>(Base::VT_LO_TYPE, Some(Bound::NONE)).unwrap()
  }
  #[inline]
  pub fn lo(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Base::VT_LO, None)
  }
  #[inline]
  pub fn hi_type(&self) -> Bound {
    self._tab.get::<Bound>(Base::VT_HI_TYPE, Some(Bound::NONE)).unwrap()
  }
  #[inline]
  pub fn hi(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Base::VT_HI, None)
  }
  #[inline]
  pub fn replaced_root(&self) -> u64 {
    self._tab.get::<u64>(Base::VT_REPLACED_ROOT, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_leaf(&'a self) -> Option<Leaf> {
    if self.data_type() == Data::Leaf {
      self.data().map(|u| Leaf::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_index(&'a self) -> Option<Index> {
    if self.data_type() == Data::Index {
      self.data().map(|u| Index::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn lo_as_inclusive(&'a self) -> Option<Inclusive> {
    if self.lo_type() == Bound::Inclusive {
      self.lo().map(|u| Inclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn lo_as_exclusive(&'a self) -> Option<Exclusive> {
    if self.lo_type() == Bound::Exclusive {
      self.lo().map(|u| Exclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn lo_as_infinity(&'a self) -> Option<Infinity> {
    if self.lo_type() == Bound::Infinity {
      self.lo().map(|u| Infinity::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn hi_as_inclusive(&'a self) -> Option<Inclusive> {
    if self.hi_type() == Bound::Inclusive {
      self.hi().map(|u| Inclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn hi_as_exclusive(&'a self) -> Option<Exclusive> {
    if self.hi_type() == Bound::Exclusive {
      self.hi().map(|u| Exclusive::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn hi_as_infinity(&'a self) -> Option<Infinity> {
    if self.hi_type() == Bound::Infinity {
      self.hi().map(|u| Infinity::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct BaseArgs {
    pub id: u64,
    pub data_type: Data,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub next: u64,
    pub lo_type: Bound,
    pub lo: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub hi_type: Bound,
    pub hi: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub replaced_root: u64,
}
impl<'a> Default for BaseArgs {
    #[inline]
    fn default() -> Self {
        BaseArgs {
            id: 0,
            data_type: Data::NONE,
            data: None,
            next: 0,
            lo_type: Bound::NONE,
            lo: None,
            hi_type: Bound::NONE,
            hi: None,
            replaced_root: 0,
        }
    }
}
pub struct BaseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Base::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: Data) {
    self.fbb_.push_slot::<Data>(Base::VT_DATA_TYPE, data_type, Data::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_DATA, data);
  }
  #[inline]
  pub fn add_next(&mut self, next: u64) {
    self.fbb_.push_slot::<u64>(Base::VT_NEXT, next, 0);
  }
  #[inline]
  pub fn add_lo_type(&mut self, lo_type: Bound) {
    self.fbb_.push_slot::<Bound>(Base::VT_LO_TYPE, lo_type, Bound::NONE);
  }
  #[inline]
  pub fn add_lo(&mut self, lo: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_LO, lo);
  }
  #[inline]
  pub fn add_hi_type(&mut self, hi_type: Bound) {
    self.fbb_.push_slot::<Bound>(Base::VT_HI_TYPE, hi_type, Bound::NONE);
  }
  #[inline]
  pub fn add_hi(&mut self, hi: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_HI, hi);
  }
  #[inline]
  pub fn add_replaced_root(&mut self, replaced_root: u64) {
    self.fbb_.push_slot::<u64>(Base::VT_REPLACED_ROOT, replaced_root, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Base<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod Frag
}  // pub mod Sled

